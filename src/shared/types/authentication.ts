/**
 * The length of salt, in bytes
 */
export const SALT_LEN = 32;
/**
 * The length of nonces, in bytes
 */
export const NONCE_LEN = 16;
/**
 * The length of a viable key, in bytes
 */
export const KEY_LEN = 32;
/**
 * The encryption algorithm for WebSocket work
 */
export const ENC_ALG = 'aes-256-ctr';
/**
 * The hashing algorithm used for fingerprints
 */
export const HASH_ALG = 'sha256';
/**
 * Payload for a new user
 */
export interface NewUserPayload {
    /**
     * The handle for this user
     *
     * Must have been generated by `generateHandle`
     */
    handle: string;
    /**
     * The plaintext password to use for this user
     */
    password: string;
}
export function isNewUser(user: unknown): user is NewUserPayload {
    const payload = <NewUserPayload>user;
    if (typeof user !== 'object' || user === null || user === undefined) {
        return false;
    } else if (!('handle' in user && 'password' in user)) {
        return false;
    } else if (
        typeof payload.handle !== 'string' ||
        typeof payload.password !== 'string'
    ) {
        return false;
    } else if (payload.password.length === 0 || payload.handle.length === 0) {
        return false;
    } else {
        return true;
    }
}

/**
 * Enumeration for device types
 */
export enum DeviceType {
    Mobile = 'mobile',
    Tablet = 'tablet',
    Desktop = 'desktop',
    Unknown = 'unknown',
}

/**
 * Initial Device Enrollment Payload
 */
export interface DEInit {
    /**
     * The handle for the device to be registered
     */
    handle: string;
    /**
     * The Unique (preferably globally so) ID of the device
     */
    deviceID: string;
}
export function isDEInit(init: unknown): init is DEInit {
    const payload = <DEInit>init;
    if (typeof init !== 'object' || init === null || init === undefined) {
        return false;
    } else if (
        !(
            'handle' in init &&
            'deviceID' in init &&
            Object.keys(init).length === 2
        )
    ) {
        return false;
    } else if (
        typeof payload.handle !== 'string' ||
        typeof payload.deviceID !== 'string'
    ) {
        return false;
    } else if (payload.deviceID.length === 0 || payload.handle.length === 0) {
        return false;
    } else {
        return true;
    }
}
/**
 * Payload for Initial Enrollment Response
 */
export interface DEInitResponse {
    /**
     * The salt to use for password hashing
     */
    salt: string;
    /**
     * A nonce to use for fingerprinting
     */
    nonce: string;
}
export function isDEInitResponse(init: unknown): init is DEInitResponse {
    const payload = <DEInitResponse>init;
    if (typeof init !== 'object' || init === null || init === undefined) {
        return false;
    } else if (!('salt' in init && 'nonce' in init)) {
        return false;
    } else if (
        typeof payload.salt !== 'string' ||
        typeof payload.nonce !== 'string'
    ) {
        return false;
    } else if (payload.salt.length === 0 || payload.nonce.length === 0) {
        return false;
    } else {
        return true;
    }
}
/**
 * Payload for the completion of Device Enrollment
 */
export interface DEComplete {
    /**
     * The handle to use
     */
    handle: string;
    /**
     * The Unique Device ID to use
     */
    deviceID: string;
    /**
     * The calculated fingerprint for verification
     */
    fingerprint: string;
    /**
     * The optional device information
     */
    info?: {
        /**
         * The human-readable name for this device
         */
        name?: string;
        /**
         * The Operating System (i.e., iOS, Windows 10, ...)
         */
        os?: string;
        /**
         * The type of device
         */
        type?: DeviceType;
    };
}
export function isDEComplete(comp: unknown): comp is DEComplete {
    const payload = <DEComplete>comp;
    if (typeof comp !== 'object' || comp === null || comp === undefined) {
        return false;
    } else if (
        !('handle' in comp && 'deviceID' in comp && 'fingerprint' in comp)
    ) {
        return false;
    } else if (
        typeof payload.handle !== 'string' ||
        typeof payload.deviceID !== 'string' ||
        typeof payload.fingerprint !== 'string'
    ) {
        return false;
    } else if (payload.handle.length === 0 || payload.deviceID.length === 0) {
        return false;
    } else if (Buffer.from(payload.fingerprint, 'base64').length !== KEY_LEN) {
        return false;
    } else {
        return true;
    }
    // No need to check the info payload... if it's there, it's there, otherwise not.
}
/**
 * Encrypted information, suitable for sending down a WebSocket
 */
export interface EncryptedPayload {
    /**
     * The Initialization Vector, as a Base64-encoded string
     */
    iv: string;
    /**
     * Encrypted payload, as a Base64-encoded string
     *
     * Note that decryption **first** requires decoding from Base64.
     */
    payload: string;
}
export function isEncryptedPayload(p: unknown): p is EncryptedPayload {
    if (typeof p !== 'object' || p === null) {
        return false;
    } else if (!('iv' in p && 'payload' in p)) {
        return false;
    }
    const payload = <EncryptedPayload>p;
    if (typeof payload.iv !== 'string' || typeof payload.payload !== 'string') {
        return false;
    } else if (Buffer.from(payload.iv, 'base64').length !== 16) {
        return false;
    }
    return true;
}
/**
 * Opening payload for the WebSocket handshake
 */
export interface WSOpener {
    /**
     * The handle used for initiation
     */
    handle: string;
    /**
     * The device that is initiating contact
     */
    deviceID: string;
    /**
     * The encrypted nonce
     *
     * Note: This should be encrypted with the shared secret fingerprint
     */
    devNonce: EncryptedPayload;
}
export function isWSOpener(ws: unknown): ws is WSOpener {
    const payload = <WSOpener>ws;
    if (typeof ws !== 'object' || ws === null || ws === undefined) {
        return false;
    } else if (!('handle' in ws && 'deviceID' in ws && 'devNonce' in ws)) {
        return false;
    } else if (
        typeof payload.deviceID !== 'string' ||
        typeof payload.handle !== 'string' ||
        !isEncryptedPayload(payload.devNonce)
    ) {
        return false;
    } else if (payload.deviceID.length === 0 || payload.handle.length === 0) {
        return false;
    } else {
        return true;
    }
}
/**
 * Server response for WebSocket Handshake
 */
export interface WSOpenResponse {
    /**
     * The incremented device Nonce
     */
    devInc: EncryptedPayload;
    /**
     * The server nonce
     */
    srvNonce: EncryptedPayload;
}
export function isWSOpenResponse(ws: unknown): ws is WSOpenResponse {
    const payload = <WSOpenResponse>ws;
    if (typeof ws !== 'object' || ws === null || ws === undefined) {
        return false;
    } else if (!('devInc' in ws && 'srvNonce' in ws)) {
        return false;
    } else if (
        !isEncryptedPayload(payload.devInc) ||
        !isEncryptedPayload(payload.srvNonce)
    ) {
        return false;
    } else {
        return true;
    }
}

// eslint-disable-next-line
interface SocketConfig {}
function isSocketConfig(config: unknown): config is SocketConfig {
    if (typeof config !== 'object' || config === null || config === undefined) {
        return false;
    } else {
        return true;
    }
}
/**
 * Last part of the WebSocket handshake
 */
export interface WSComplete {
    /**
     * Incremented Server Nonce
     */
    srvInc: EncryptedPayload;
    /**
     * Socket Configuration
     */
    config: SocketConfig;
}
export function isWSComplete(ws: unknown): ws is WSComplete {
    const payload = <WSComplete>ws;
    if (typeof ws !== 'object' || ws === null || ws === undefined) {
        return false;
    } else if (!('srvInc' in ws && 'config' in ws)) {
        return false;
    } else if (
        !isEncryptedPayload(payload.srvInc) ||
        !isSocketConfig(payload.config)
    ) {
        return false;
    } else {
        return true;
    }
}

/**
 * Payload for changing the password
 */
export interface NewPasswordPayload {
    /**
     * The handle for the user whose password is changing
     */
    handle: string;
    /**
     * The user's current plaintext password
     */
    oldPassword: string;
    /**
     * The user's new plaintext password
     */
    newPassword: string;
}
export function isNewPassword(pass: unknown): pass is NewPasswordPayload {
    const payload = <NewPasswordPayload>pass;
    if (typeof pass !== 'object' || pass === null || pass === undefined) {
        return false;
    } else if (
        !('handle' in pass && 'oldPassword' in pass && 'newPassword' in pass)
    ) {
        return false;
    } else if (
        typeof payload.handle !== 'string' ||
        typeof payload.oldPassword !== 'string' ||
        typeof payload.newPassword !== 'string'
    ) {
        return false;
    } else if (
        payload.newPassword.length === 0 ||
        payload.handle.length === 0
    ) {
        return false;
    } else {
        return true;
    }
}
/**
 * Payload for deleting a user
 */
export interface DeletePayload {
    /**
     * Handle of the user to delete
     */
    handle: string;
    /**
     * The password hash of the user
     */
    hash: string;
}
export function isDeletePayload(del: unknown): del is DeletePayload {
    const payload = <DeletePayload>del;
    if (typeof del !== 'object' || del === null || del === undefined) {
        return false;
    } else if (!('handle' in del && 'hash' in del)) {
        return false;
    } else if (
        typeof payload.handle !== 'string' ||
        typeof payload.hash !== 'string'
    ) {
        return false;
    } else if (payload.handle.length === 0 || payload.hash.length === 0) {
        return false;
    } else {
        return true;
    }
}
